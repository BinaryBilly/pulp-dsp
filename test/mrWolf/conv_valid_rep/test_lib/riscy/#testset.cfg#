import sys, os
sys.path.append(os.path.abspath(os.path.join(os.path.realpath(__file__), "../../../..")))
from pulp_dsp_test import SweepVariable, DynamicVariable
from pulp_dsp_test import Argument, ArrayArgument, FixPointArgument, OutputArgument
from pulp_dsp_test import generate_test

# Variables:
# ---------
# Can either be SweepVariable or Dynamic Variable. The name can then be used for the arguments (as
# value or as dimension).
#
# SweepVariable:   Type of variable which can be used to sweep over values.
# DynamicVariable: Variable that is determined by previously defined variables (SweepVariables or
#                  other Dynamic Variables). Dynamic variables need a funciton, which takes an
#                  environment as argument. This environment is a dictionary which maps the names
#                  of previously defined variables (position in the variables list) to their values.
#
# Arguments:
# ---------
# Defines the arguments of the funciton. These can be one of the following:
#
# Argument(name, type, value):
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     value: Either a number, the name of a Variable or None for a random value
# FixedPointArgument(name, type, value): Same as Argument, but only used for fixpoint implementation
# ArrayArgument(name, type, length, value)
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     length: Either a number, or the name of a Variable or a tuple for randint(min, max)
#     value: Either a number, the name of a Variable or None for a random value
# OutputArgument(name, type, length)
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     length: Either a number, or the name of a Variable or a tuple for randint(min, max)
#
# Implemented:
# -----------
# Dictionary which maps the function type (i8, i16, i32, q8, q16, q32, f32) to a boolean to tell
# if this version is implemented and should be tested.

device_name = 'riscy'
function_name = 'plp_conv_valid_rep'

variables = [
	SweepVariable('len_a', [127, 128, 257, 514]),
	SweepVariable('len_b', [3, 15, 32, 65, 66]),
	DynamicVariable('len_y', lambda env: abs(env['len_a'] - env['len_b']) + 1),
]

arguments = [
	ArrayArgument('srcA', 'var_type', 'len_a', None, use_l1=),
	Argument('srcALen', 'uint32_t', 'len_a'),
	ArrayArgument('srcB', 'var_type', 'len_b', None),
	Argument('srcBLen', 'uint32_t', 'len_b'),
	FixPointArgument('deciPoint', 'uint32_t', 12),
	OutputArgument('pRes', 'int32_t', 'len_y'),
]

implemented = {
	'i32': False,
	'i16': False,
	'i8':  True,
	'q32': False,
	'q16': False,
	'q8':  False,
	'f32': False
}

TestConfig = c = generate_test(device_name, function_name, arguments, variables, implemented, use_l1=False)