import sys, os
sys.path.append(os.path.abspath(os.path.join(os.path.realpath(__file__), "../../..")))
from pulp_dsp_test import SweepVariable, DynamicVariable
from pulp_dsp_test import Argument, ArrayArgument, FixPointArgument, OutputArgument, ParallelArgument
from pulp_dsp_test import generate_test

# Variables:
# ---------
# Can either be SweepVariable or Dynamic Variable. The name can then be used for the arguments (as
# value or as dimension).
#
# SweepVariable:   Type of variable which can be used to sweep over values.
# DynamicVariable: Variable that is determined by previously defined variables (SweepVariables or
#                  other Dynamic Variables). Dynamic variables need a funciton, which takes an
#                  environment as argument. This environment is a dictionary which maps the names
#                  of previously defined variables (position in the variables list) to their values.
#
# Arguments:
# ---------
# Defines the arguments of the funciton. These can be one of the following:
#
# Argument(name, type, value, use_l1):
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     value: Either a number, the name of a Variable or None for a random value
#     use_l1: boolean, for using l1 or l2 memory.
# FixedPointArgument(name, value, use_l1): Same as Argument, but only used for fixpoint
#                                          implementation
# ParallelArgument(name, value, use_l1): Same as Argument, but only used for parallel implementation
# ArrayArgument(name, type, length, value, use_l1)
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     length: Either a number, or the name of a Variable or a tuple for randint(min, max)
#     value: Either a number, the name of a Variable or None for a random value
#     use_l1: boolean, for using l1 or l2 memory.
# OutputArgument(name, type, length, use_l1, tolerance)
#     name: Name of the argument (as in function declaration)
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     length: Either a number, or the name of a Variable or a tuple for randint(min, max)
#     use_l1: boolean, for using l1 or l2 memory.
#     tolerance: Either a constant (default 0) or a function which maps the version name to a
#                relative tolerance
# ReturnValue(ctype, use_l1, tolerance): Value which is returned by the function
#     type: Either a ctype, or 'var_type' | 'ret_type' when determined by the version
#     use_l1: boolean, for using l1 or l2 memory.
#     tolerance: Either a constant (default 0) or a function which maps the version name to a
#                relative tolerance
#
# Implemented:
# -----------
# Dictionary which maps the device name ('ibex' or 'riscy') to a different dictionary. This second
# Dictionary maps the function type (i8, i16, i32, q8, q16, q32, f32) to a boolean to tell if this
# version is implemented on the given device and should be tested. Add the suffix _parallel to test
# the parallel implementation
#
# n_ops:
# -------
# Function with one parameter: env, which computes the number of operations (like macs) based on the
# sweep variables. Parameter env is a dict, mapping the name of the variable to the value for the
# specific test.

function_name = 'plp_mat_mult_stride'

variables = [
	SweepVariable('len_m', [1, 16, 17]),
	SweepVariable('len_n', [1, 24, 25]),
	SweepVariable('len_o', [1, 8, 9]),
	SweepVariable('lA', [1], visible=False),
	SweepVariable('lB', [1], visible=False),
	SweepVariable('lC', [0, 1], visible=False),
	DynamicVariable('strideA', lambda e: e['len_n'] + e['lA']),
	DynamicVariable('strideB', lambda e: e['len_o'] + e['lB']),
	DynamicVariable('strideC', lambda e: e['len_o'] + e['lC']),
	DynamicVariable('len_srcA', lambda e: e['len_m'] * e['strideA'], visible=False),
	DynamicVariable('len_srcB', lambda e: e['len_n'] * e['strideB'], visible=False),
	DynamicVariable('len_res', lambda e: e['len_m'] * e['strideC'], visible=False),
]

arguments = [
	ArrayArgument('srcA', 'var_type', 'len_srcA', None),
	ArrayArgument('srcB', 'var_type', 'len_srcB', None),
	Argument('len_m', 'uint32_t', 'len_m'),
	Argument('len_n', 'uint32_t', 'len_n'),
	Argument('len_o', 'uint32_t', 'len_o'),
	Argument('strideA', 'uint32_t', 'strideA'),
	Argument('strideB', 'uint32_t', 'strideB'),
	Argument('strideC', 'uint32_t', 'strideC'),
	FixPointArgument('shift', 4),
	ParallelArgument('nPe', 8),
	OutputArgument('pRes', 'ret_type', 'len_res', tolerance=lambda v: 1e-2 if v.startswith('f') else 10 if v.startswith('q') else 0),
]

implemented = {
	'riscy': {
		'i32': True,
		'i16': True,
		'i8':  True,
		'q32': True,
		'q16': True,
		'q8':  True,
		'f32': True,
		'i32_parallel': True,
		'i16_parallel': True,
		'i8_parallel':  True,
		'q32_parallel': True,
		'q16_parallel': True,
		'q8_parallel':  True,
		'f32_parallel': True
	},
	'ibex': {
		'i32': True,
		'i16': True,
		'i8':  True,
		'q32': True,
		'q16': True,
		'q8':  True,
	},
}

n_ops = lambda env: env['len_m'] * env['len_n'] * env['len_o']

arg_ret_type = {
	'q32': ('int32_t', 'int32_t'),
	'q16': ('int16_t', 'int16_t'),
	'q8':  ('int8_t', 'int8_t')
}

TestConfig = c = generate_test(function_name, arguments, variables, implemented, use_l1=True, n_ops=n_ops, arg_ret_type=arg_ret_type)
