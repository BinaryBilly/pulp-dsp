arguments = []
implemented = dict()

# Arguments consist of follwoing properties:
# name: 	spelled out name that argument should have
# type: 	type of the argument, can either be fixed by giving the type directly,
# 			or sweeped thorugh
# lenght: 	defines lenght of argument 1 for single values, 2 or more for arrays
# arg_type: has following options:
# 			0:	random values that need to be generated
# 			1:	fixed initialized value
# 			2:	output arguments that need space to write to, but need not be initialized
# 				are always represented by a pointer (array of lenght 1 or more will be generated)
# 			3:	values that should be sweeped, give values to be tested in value field
# value:	value that should be used to initialize

class argument(object):
	"""docstring for argument"""
	def __init__(self, name, a_type, length, arg_type, value):
		super(argument, self).__init__()
		self.name = name
		self.type = a_type
		self.length = length
		self.arg_type = arg_type
		self.value = value

def add_arg(name, type, length, arg_type ,value):
	arguments.append(argument(name, type, length, arg_type, value))

###############################################################
# 
# Function Defines Below this
# 
###############################################################

FNAME = 'plp_dot_prod_i32'

add_arg('v_a', 'int32_t','length', 0, 0)
add_arg('v_b', 'int32_t','length', 0, 0)
add_arg('length', 'int32_t',1, 4, [10,12])
add_arg('comp_result','int32_t',1, 2, 0)

# set implemented version to true in list bellow:
implemented['int32']	= True
implemented['int16']	= False
implemented['int8']		= False
implemented['q32']		= False
implemented['q16']		= False
implemented['q8']		= False
implemented['float']	= False


###############################################################
# 
# Do not change below this line
# 
###############################################################

from plptest import *

TestConfig = c = {}

c['tests'] = [ ]

def check_output(config, output):
	
	for item in output.split('\n'):
		if 'Test passed:' in item:
			print(item)
		elif 'Total cycles:' in item:
			print(item)
		elif 'Instructions:' in item:
			print(item)
		elif 'comp_result:' in item:
			print(item)

	# if output.find('Hello !') == -1:
		# return (False, "Didn't find output string")
	return (True, None)

def add_test(name,flags):
	return Test(
		name = 'test %s' % name,
		commands = [
			Shell('clean', 'make clean %s' % (flags)),
			Shell('gen', 'make gen %s' % (flags)),
			Shell('build', 'make all %s' % (flags)),
			Shell('run', 'make run %s' % (flags)),
			Check('check', check_output)
		],
		timeout = 1000000
	)

def sweep_range(signature ,arglist, index, sweep_dict):
	if index < len(arglist):
		arg = arglist[index]
		if arg.arg_type == 4:
			for value in arg.value:
				new_sweep_dict = sweep_dict.copy()
				new_sweep_dict[arg.name] = value
				sweep_range(signature, arglist, index+1, new_sweep_dict)
		else:
			sweep_range(signature, arglist, index+1, sweep_dict)
	else:
		GARGS = ''
		for arg in arglist:
			GARGS = GARGS + ' --arg ' + arg.name
			GARGS = GARGS + ' ' + arg.type
			if type(arg.length) == int:
				GARGS = GARGS + ' ' + str(arg.length)
			elif type(arg.length) == str:
				if arg.length in sweep_dict:
					value = sweep_dict[arg.length]
					GARGS = GARGS + ' ' + str(value)
				else:
					print('%s has lenght that is not determined' % (arg.name))
			else:
				print('%s lenght neither string nor int')
			if arg.arg_type == 4:
				GARGS = GARGS + ' ' + str(1)
				GARGS = GARGS + ' ' + str(sweep_dict[arg.name])
			else:
				GARGS = GARGS + ' ' + str(arg.arg_type)
				GARGS = GARGS + ' ' + str(arg.value)

		GARGS = 'GARGS=\'' + GARGS + '\''
		print(GARGS)
		FLAGS = signature + ' ' + GARGS
		test_name = FNAME
		for key, value in sweep_dict.items():
			test_name = test_name + ' ' + key + ' ' + str(value)
		c['tests'].append(add_test(test_name, FLAGS))

FSIG = ''
for arg in arguments:
	if FSIG == '':
		FSIG = arg.name
	else:
		FSIG = FSIG + ', ' + arg.name

FSIG = FNAME + '(' + FSIG + ')'
FSIG = 'FSIG=\'-D FSIG=\"' + FSIG + '\"\''

print(FSIG)

sweep_range(FSIG, arguments, 0, dict())